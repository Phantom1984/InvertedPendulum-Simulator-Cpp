### 1.倒立摆稳定后，小车一直向前缓慢位移

```c++
/*时间   位移    角度*/
4.90, 6.17058, 2.00199e-05
4.91, 6.18366, 1.9463e-05
4.92, 6.19675, 1.89216e-05
4.93, 6.20984, 1.83953e-05
4.94, 6.22292, 1.78836e-05
4.95, 6.23601, 1.73861e-05
4.96, 6.24909, 1.69025e-05
4.97, 6.26218, 1.64323e-05
4.98, 6.27526, 1.59753e-05
4.99, 6.28835, 1.55309e-05
5.00, 6.30143, 1.50989e-05
```

经研究，发现是小车未启用摩擦，初始状态的能量一直没有消耗，残余的速度可能会让小车一直前进

- [x] 准确的小车摩擦模型

- [x] 单角度环有摩擦时的控制

- [ ] 位置+角度双闭环控制

- [ ] 速度+角度双闭环控制

- [ ] 积分项研究

- [x] LQR

- [ ] 其它算法（滑模控制、MPC控制...）

目前有个奇怪的现象，就是控制力输入必须是负的，然后摩擦系数也得是负的才能保证现象正确。怀疑是建模除了问题，但是模型改了很多次，都没用。做过的验证

1.控制力为0，摩擦为0，初始位置为1
现象：小车在1附近来回摆动，摆做正弦运动

2.控制力为0，摩擦为5，初始位置为1
现象：小车在1停下，摆的角度最终为180度。

新想法：180°时是倒挂，而当角度为181°时，差值是否应该为179°而非181°？

暂时先别研究了，先试试LQR能否成功

### 2025.3.17

打算稍微重构一下部分代码，因为没考虑多输入多输出的情况，用继承controller.h抽象类的方案不合理。

今天学了不少关于LQR的知识。LQR全名叫线性二次型调节器，是一种基于模型的最优控制理论（类似MPC），因此它需要线性化的模型。LQR的基本思想可分为以下几步：

1. **建立系统的状态空间模型。**如果是非线性系统，还需要选择工作点进行线性化。一般来说都选择不稳定的平衡点进行。比如小车倒立摆就选取摆杆倒立处，因为一般的需求都是如此。如果在别处比如水平位置线性化，可能无法准确描述出系统的状态，也有可能很难稳定。
2. **设计状态反馈控制。**通过计算得到的状态反馈矩阵K，计算得到**控制量$$u=-Kx$$**，使之能在控制$$u$$的作用下最终能收敛。这里隐约和前面挂钩了，因为如果平衡点线性化设置的不合理，可能无法通过极点配置来使得系统稳定。
3. **设计代价函数$$J$$**，一般为二次型，包括状态$$x$$和控制$$u$$，对应$$Q$$和$$R$$矩阵，为对角矩阵，这也是LQR需要调节参数的部分
4. 利用最优控制理论，将控制量$$u=-Kx$$带入代价函数，最终推导得到**黎卡提方程**。这里的过程十分复杂，但是最终结果是确定的。所以对于工程实现，只需要用最后的方程推导结果即可。得到黎卡提方程后，将其求解得到状态反馈矩阵$$K$$。
5. 将得到的$$K$$与状态$$x$$相乘得到控制量

在工程实现中，最关键的就是黎卡提方程的求解。因为只要通过它得到K，那么控制量就出来了，然后输入到系统就完事了。通常来说，离散的黎卡提方程求解很关键。其表达式如下：
$$
P_{k+1}=A_d^TP_kA_d-A_d^TP_kB_d(R+B_d^TP_kB_d)^{-1}B_d^TP_kA_d+Q
$$
注意，这里的系统矩阵和控制矩阵分别是**$$A_d$$和$$B_d$$，是离散化后的，和连续系统的$$A$$与$$B$$不一样！**可以看出是一个随时间的递推关系，可以用不动点迭代法求解：步骤如下：

1. 初始化$$P_0=Q$$，并设置最大迭代次数max_iter。
2. 在for循环中进行迭代，根据离散表达式计算P_next，即$$P_{k+1}$$。
3. 计算容差，若$$|P_{k+1}-P_k|<\varepsilon$$，则终止迭代。
4. 利用P计算反馈矩阵K，进而计算控制量u。

离散化的系统矩阵变换：
$$
A_d=I+A·T,B_d=B·T
$$
离散形式的增益矩阵计算：
$$
K=(R+B^TP_{k+1}B)^{-1}B^TP_{k+1}A
$$
连续时间微分黎卡提方程：
$$
P_{\text {next }}=P+\left(A^{\top} P+P A-P B R^{-1} B^{\top} P+Q\right) \Delta t
$$
连续形式的增益矩阵计算：
$$
K = R^{-1}B^TP
$$

### 2025.4.1

经验证，LQR是可行的，它可以让小车稳定在状态变量的所有平衡点，没有漂移现象。但是得注意一些参数不能设置的太离谱，比如偏离平衡点过大，否则会不收敛，比如初始位置或角度离平衡点过远，摩擦系数过大等。接下来全力研究pid控制

### 2025.4.2

目前pid的矛盾点在于，必须在函数里施加负的力才行，但是实际情况应该不需要这么做。例如，当角度向正方向（向左）偏移20度，小车应该向左运动，然而仿真结果表明，小车向右移动了。在不施加力的情况下小车运动是正确的。后来发现，这和初始建模相关。我一开始用的别人的模型，发现那个模型的小车角度向右为正，因此在计算pid时，由于是setval-fd，当初始角度为正，设定为0，pid输出为负，会让小车向左移动，因此导致发散。如果在输出前加入负号，同时保证摩擦系数与力的方向相反，才能正确。

因此为了保证正确的输出，即不加负号，需要正确的建模。默认情况下角度逆时针为正，因此应该按照逆时针进行建模

可能有人会问，为什么一定要遵循这个标准呢？假如我一开始并不知道逆时针是正，但是我按照标准的pid公式编写代码，即设定值-反馈值，结果出错，但是又找不到原因，太奇怪了！

这里我想说，因为pid的这个标准写法是按照负反馈标准来写的，就是设定值-反馈值，这个没有问题。问题出在，我们定义的力的方向和角度同向了。负反馈就是控制量与误差负号相反。这么想吧，我们一开始不考虑角度左还是右，只考虑正负，假如一开始角度为正偏，那么按照设定值-反馈值，误差为负，此时控制量一定为负，而我们定义的负方向刚好与摆杆倒下的方向相反！因此想要维持力矩平衡，必须施加反向控制力，这就是原因。因为pid是标量，只有大小，没有方向，或者说，初始的方向需要我们认为设定好。

那么现在怎么解决这个问题呢，有两种思路：

1. 把F和摩擦力全部取反，即把向左的力定位正方向，让它与摆杆正方向相反。
2. 重新按照标准建模，即小车右为正，逆时针角度为正

为了标准起见，我决定重新建模，选择思路2

重新建模后

1. 无摩擦稳定时小车向左匀速运动
2. 摩擦系数为正时小车无法稳定，必须为负。
3. 去掉角加速度里的摩擦项，摩擦系数为正时可以稳定

测试

- 设置初始速度为10，位置为0，摩擦系数为5，pendulum.update(0, dt);时，小车会向右移动，最终停下，摆杆也稳定在180度。说明模型没有问题。然后pendulum.update(control_pid, dt)，小车一开始会向左运动，摆杆也向0度的位置旋转，但过一会儿快到平衡点时它有加速逆时针旋转，最后稳定在180度的位置波动，然后此时小车停止加速，开始减速至匀速运动
- 摩擦系数为1，加入10的积分项，摆杆稳定，小车匀速向前
- 摩擦系数为5，加入10的积分项，摆杆在180度附近波动
- 摩擦系数为1，加入60的积分项，摆杆收敛，小车匀速向前
- 摩擦系数为5，加入60的积分项，摆杆收敛，小车匀速向前

分析

- 由前面的测试可以发现，模型应该是没问题的。然后一开始小车向左运动，摆杆也向平衡点运动，说明控制是有用的，系统正在趋于稳定。但是当快到平衡点时系统突然发散，说明很可能是控制器出了问题
- 有摩擦也不能让小车停下，可能得加入位置环或者速度环
- 普通单级pid需要调参，加入积分项

问题解决了，加入积分项即可，然后关键在于调参。各项参数的物理意义后续再研究，接下来研究双闭环控制，先从位置环+角度环开始

### 2025.4.3
